#! /bin/zsh

# The location of the `ex_cldr` repo
export EX_CLDR="${EX_CLDR:=$HOME/Development/cldr}"
[ ! -d $EX_CLDR ] && { echo "ex_cldr repository $EX_CLDR was not found."; exit 1; }

# The location of the cloned CLDR repo
export CLDR_REPO="${CLDR_REPO:=$HOME/Development/cldr_repo}"
[ ! -d $CLDR_REPO ] && { echo "Unicode CLDR repository $CLDR_REPO was not found."; exit 1; }

# Location of where the staging data should
# be provisioned.
export CLDR_STAGING="${CLDR_STAGING:=$HOME/Development/cldr_staging_data}"
[ ! -d $CLDR_STAGING ] && { echo "Unicode CLDR staging directory $CLDR_STAGING was not found."; exit 1; }
mkdir -p $CLDR_STAGING/seed/main

# Location where the production data will be
# provisioned.
export CLDR_PRODUCTION="${CLDR_PRODUCTION:=$HOME/Development/cldr_production_data}"
[ ! -d $CLDR_PRODUCTION ] && { echo "Unicode CLDR production directory $CLDR_PRODUCTION was not found."; exit 1; }

# The location of the CLDR utilities jar
# This location is autogenerated and should not need to
# be adjusted
export CLDR_CODE_DIR="$CLDR_REPO"
export CLDR_TOOLS="$CLDR_CODE_DIR/tools/cldr-code/target/cldr-code.jar"

# Rebuild the tools
cd $CLDR_CODE_DIR
mvn package -pl cldr-code --file=tools/pom.xml -DskipTests=true

cd $CLDR_REPO

# Expand to production data which will go in
# $CLDR_STAGING
java -DCLDR_DIR=$CLDR_REPO \
  -jar $CLDR_TOOLS org.unicode.cldr.tool.GenerateProductionData \
  -s $CLDR_REPO/common \
  -d $CLDR_STAGING/common

# We do this since processing all locales in a single run
# reliably emits all locales (the consolidated
# version does not). Therefore the working approach is to
# do the following first

# for FULLPATH in $CLDR_REPO/common/main/*.xml; do
#   LOCALE=$FULLPATH:t:r
#   java -DCLDR_DIR=$CLDR_STAGING \
#     -jar $CLDR_TOOLS ldml2json \
#     -d $CLDR_PRODUCTION -p true -r true -t main -m $LOCALE
# done

# Data will be generated into $CLDR_PRODUCTION
# -Xmx16g may be too much but the default is definitely too small
# and will cause an out of heap memory exception
java -Xmx16g -DCLDR_DIR=$CLDR_STAGING \
  -jar $CLDR_TOOLS ldml2json \
  -d $CLDR_PRODUCTION -p true -r true -t

java -DCLDR_DIR=$CLDR_STAGING \
  -jar $CLDR_TOOLS ldml2json \
  -d $CLDR_PRODUCTION -p true -r true -t supplemental

java -DCLDR_DIR=$CLDR_STAGING \
  -jar $CLDR_TOOLS ldml2json \
  -d $CLDR_PRODUCTION -p true -r true -t rbnf

# Some data we process directly from the XML
cp $CLDR_REPO/common/supplemental/units.xml $CLDR_PRODUCTION
cp $CLDR_REPO/common/supplemental/pluralRanges.xml $CLDR_PRODUCTION/plural_ranges.xml
cp $CLDR_REPO/common/supplemental/subdivisions.xml $CLDR_PRODUCTION

mkdir -p $CLDR_PRODUCTION/subdivisions
cp $CLDR_STAGING/common/subdivisions/* $CLDR_PRODUCTION/subdivisions

# Validity data for language, script and territory
mkdir -p $CLDR_PRODUCTION/validity
cp -R $CLDR_REPO/common/validity/ $CLDR_PRODUCTION/validity/

# BCP 47 data for validating U and T extension values
mkdir -p $CLDR_PRODUCTION/bcp47
cp -R $CLDR_REPO/common/bcp47/ $CLDR_PRODUCTION/bcp47/

# ex_cldr additional data required for data generation
cp $EX_CLDR/data/iso_currencies.xml $CLDR_PRODUCTION/iso_currencies.xml

# Data that maps from Unicode script names to Script code (subtag)
cp $CLDR_REPO/tools/cldr-code/src/main/resources/org/unicode/cldr/util/data/Script_Metadata.csv \
   $EX_CLDR/priv/cldr/script_metadata.csv

# Copy test data
cp $CLDR_REPO/common/testData/localeIdentifiers/localeCanonicalization.txt \
   $EX_CLDR/test/data/locale_canonicalization.txt

cp $CLDR_REPO/common/testData/units/unitPreferencesTest.txt \
   $EX_CLDR/test/data/preference_test_data.txt

cp $CLDR_REPO/common/testData/units/unitsTest.txt \
   $EX_CLDR/test/data/conversion_test_data.txt

cd $OLDPWD
